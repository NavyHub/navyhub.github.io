<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title> Kubernetes中的Secret配置详解 - jimmysong.io|宋净超的博客|Cloud Native Developer Advocate</title>
  <meta name="description" content="jimmysong.io|宋净超的博客|Cloud Native Developer Advocate" />
  <meta property="og:title" content="Kubernetes中的Secret配置详解" />
  <meta name="twitter:title" content="Kubernetes中的Secret配置详解" />
  <meta name="description" content="Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 ssh key。将这些信息放在 secret 中比放在 pod 的定义中或者 docker 镜像中来说更加安全和灵活。参阅 Secret 设计">
  <meta property="og:description" content="Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 ssh key。将这些信息放在 secret 中比放在 pod 的定义中或者 docker 镜像中来说更加安全和灵活。参阅 Secret 设计">
  <meta name="twitter:description" content="Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 ssh key。将这些信息放在 secret 中比放在 pod 的定义中或者 docker 镜像中来说更加安全和灵活。参阅 Secret 设计">
  <meta name="author" content="Jimmy Song(宋净超)"/>
  <link href='https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/avatar-icon.png" />
  <meta name="twitter:image" content="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@jimmysongio" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/posts/kubernetes-secret-configuration/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Jimmy Song" />

  <meta name="generator" content="Hugo 0.40" />
  <link rel="canonical" href="https://jimmysong.io/posts/kubernetes-secret-configuration/" />
  <link rel="alternate" href="https://jimmysong.io/index.xml" type="application/rss+xml" title="Jimmy Song">
  <script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/jquery-1.12.4.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="https://jimmysong.io/css/main.css" />
  <link rel="stylesheet" href="https://jimmysong.io/css/search.css" />
  
  

<meta name="baidu-site-verification" content="g8IYR9SNLF" />
<script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>

<link rel="stylesheet" href="https://jimmysong.io/css/prism.css" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://jimmysong.io/">Jimmy Song</a>
    </div>
    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Categories</a>
              <div class="navlinks-children">
                
                
                  <a href="https://jimmysong.io/categories/kubernetes">kubernetes</a>
                
                
                  <a href="https://jimmysong.io/categories/cloud-native">Cloud Native</a>
                
                
                  <a href="https://jimmysong.io/categories/microservices">Microservices</a>
                
                
                  <a href="https://jimmysong.io/categories/devops">Devops</a>
                
                
                  <a href="https://jimmysong.io/categories/github">Github</a>
                
                
                  <a href="https://jimmysong.io/categories/serverless">Serverless</a>
                
                
                  <a href="https://jimmysong.io/categories/service-mesh">Service Mesh</a>
                
                
                  <a href="https://jimmysong.io/tags">Tags</a>
                
              </div>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Gitbooks</a>
              <div class="navlinks-children">
                
                
                  <a href="https://jimmysong.io/kubernetes-handbook">Kubernetes handbook</a>
                
                
                  <a href="https://jimmysong.io/docker-handbook">Docker handbook</a>
                
                
                  <a href="https://jimmysong.io/hugo-handbook">Hugo Handbook</a>
                
                
                  <a href="https://servicemesher.github.io/envoy">Envoy proxy中文文档</a>
                
                
                  <a href="https://jimmysong.io/migrating-to-cloud-native-application-architectures">Migrating to Cloud Native</a>
                
              </div>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Publications</a>
              <div class="navlinks-children">
                
                
                  <a href="https://jimmysong.io/cloud-native-go">Cloud Native Go</a>
                
                
                  <a href="https://jimmysong.io/posts/cloud-native-python">Cloud Native Python</a>
                
                
                  <a href="https://jimmysong.io/posts/cloud-native-java">Cloud Native Java</a>
                
              </div>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Projects</a>
              <div class="navlinks-children">
                
                
                  <a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster">k8s all-in-one</a>
                
                
                  <a href="https://jimmysong.io/spark-on-k8s">Spark on kubernetes</a>
                
                
                  <a href="https://jimmysong.io/posts/yarn-on-docker">Magpie</a>
                
                
                  <a href="https://jimmysong.io/cheatsheets">Cheatsheets</a>
                
                
                  <a href="https://github.com/rootsongjc/beautifulhugo">Beautifulhugo</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="About" href="/about">About</a>
              
              
            </li>
          
        

        

        
        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
          
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Jimmy Song" href="https://jimmysong.io/">
            <img class="avatar-img" src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/avatar-icon.png" alt="Jimmy Song" />
          </a>
        
      </div>
    </div>

  </div>
</nav>





  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search jimmysong.io</h4>
        </div>
        <div class="modal-body">
            
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..." name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>



<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>

<script>
var client = algoliasearch("X4YB3WOBNV", "d2134c5a8d250e6d3246594240c45201");
var index = client.initIndex('rootsongjc-hugo');

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            
            return '<span>' + '<a href="/' + suggestion.uri+ '">' +
            suggestion._highlightResult.title.value + '</a></span>';
        }
    }
});
</script>


        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">close</button>
        </div>
      </div>
    </div>
  </div>


    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12 col-md-offset-0">
            <div class="posts-heading">
                <h1 align="center">Kubernetes中的Secret配置详解</h1>
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main" itemscope itemtype="http://schema.org/Article">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            
            
            
<div>
    <section id="datecount">
        <h4 id="date"> Thu Sep 28, 2017</h4>
    </section>
    <h5 id="wc">5900 Words|Read in about 12 Min</h5>
    <h5 id="tags">Tags: 
        
        <a href="https://jimmysong.io/tags/kubernetes/">kubernetes</a> &nbsp;
    </h5>
</div>

            
            <article role="main" class="blog-post" itemprop="articleBody" id="content">
                
  
  <aside class="toc">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#secret-概览">Secret 概览</a>
<ul>
<li><a href="#内置-secret">内置 secret</a>
<ul>
<li><a href="#service-account-使用-api-凭证自动创建和附加-secret">Service Account 使用 API 凭证自动创建和附加 secret</a></li>
</ul></li>
<li><a href="#创建您自己的-secret">创建您自己的 Secret</a>
<ul>
<li><a href="#使用-kubectl-创建-secret">使用 kubectl 创建 Secret</a></li>
<li><a href="#手动创建-secret">手动创建 Secret</a></li>
<li><a href="#解码-secret">解码 Secret</a></li>
</ul></li>
<li><a href="#使用-secret">使用 Secret</a>
<ul>
<li><a href="#在-pod-中使用-secret-文件">在 Pod 中使用 Secret 文件</a></li>
<li><a href="#secret-作为环境变量">Secret 作为环境变量</a></li>
<li><a href="#使用-imagepullsecret">使用 imagePullSecret</a></li>
</ul></li>
<li><a href="#安排-imagepullsecrets-自动附加">安排 imagePullSecrets 自动附加</a>
<ul>
<li><a href="#自动挂载手动创建的-secret">自动挂载手动创建的 Secret</a></li>
</ul></li>
</ul></li>
<li><a href="#详细">详细</a>
<ul>
<li><a href="#限制">限制</a></li>
<li><a href="#secret-与-pod-生命周期的联系">Secret 与 Pod 生命周期的联系</a></li>
</ul></li>
<li><a href="#使用案例">使用案例</a>
<ul>
<li><a href="#使用案例-包含-ssh-密钥的-pod">使用案例：包含 ssh 密钥的 pod</a></li>
<li><a href="#使用案例-包含-prod-test-凭据的-pod">使用案例：包含 prod/test 凭据的 pod</a></li>
<li><a href="#使用案例-secret-卷中以点号开头的文件">使用案例：secret 卷中以点号开头的文件</a></li>
<li><a href="#使用案例-secret-仅对-pod-中的一个容器可见">使用案例：Secret 仅对 pod 中的一个容器可见</a></li>
</ul></li>
<li><a href="#最佳实践">最佳实践</a>
<ul>
<li><a href="#客户端使用-secret-api">客户端使用 secret API</a></li>
</ul></li>
<li><a href="#安全属性">安全属性</a>
<ul>
<li><a href="#保护">保护</a></li>
<li><a href="#风险">风险</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>
  


                

<p><code>Secret</code> 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 ssh key。将这些信息放在 <code>secret</code> 中比放在 <code>pod</code> 的定义中或者 docker 镜像中来说更加安全和灵活。参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/secrets.md">Secret 设计文档</a> 获取更多详细信息。</p>

<h2 id="secret-概览">Secret 概览</h2>

<p>Secret 是一种包含少量敏感信息例如密码、token 或 key 的对象。这样的信息可能会被放在 Pod spec 中或者镜像中；将其放在一个 secret 对象中可以更好地控制它的用途，并降低意外暴露的风险。</p>

<p>用户可以创建 secret，同时系统也创建了一些 secret。</p>

<p>要使用 secret，pod 需要引用 secret。Pod 可以用两种方式使用 secret：作为 <a href="https://kubernetes.io/docs/concepts/storage/volumes">volume</a> 中的文件被挂载到 pod 中的一个或者多个容器里，或者当 kubelet 为 pod 拉取镜像时使用。</p>

<h3 id="内置-secret">内置 secret</h3>

<h4 id="service-account-使用-api-凭证自动创建和附加-secret">Service Account 使用 API 凭证自动创建和附加 secret</h4>

<p>Kubernetes 自动创建包含访问 API 凭据的 secret，并自动修改您的 pod 以使用此类型的 secret。</p>

<p>如果需要，可以禁用或覆盖自动创建和使用API凭据。但是，如果您需要的只是安全地访问 apiserver，我们推荐这样的工作流程。</p>

<p>参阅 <a href="https://kubernetes.io/docs/user-guide/service-accounts">Service Account</a> 文档获取关于 Service Account 如何工作的更多信息。</p>

<h3 id="创建您自己的-secret">创建您自己的 Secret</h3>

<h4 id="使用-kubectl-创建-secret">使用 kubectl 创建 Secret</h4>

<p>假设有些 pod 需要访问数据库。这些 pod 需要使用的用户名和密码在您本地机器的 <code>./username.txt</code> 和 <code>./password.txt</code> 文件里。</p>

<pre><code class="language-bash"># Create files needed for rest of example.
$ echo -n &quot;admin&quot; &gt; ./username.txt
$ echo -n &quot;1f2d1e2e67df&quot; &gt; ./password.txt
</code></pre>

<p><code>kubectl create secret</code> 命令将这些文件打包到一个 Secret 中并在 API server 中创建了一个对象。</p>

<pre><code class="language-bash">$ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
secret &quot;db-user-pass&quot; created
</code></pre>

<p>您可以这样检查刚创建的 secret：</p>

<pre><code class="language-bash">$ kubectl get secrets
NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s

$ kubectl describe secrets/db-user-pass
Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre>

<p>请注意，默认情况下，<code>get</code> 和 <code>describe</code> 命令都不会显示文件的内容。这是为了防止将 secret 中的内容被意外暴露给从终端日志记录中刻意寻找它们的人。</p>

<p>请参阅 <a href="https://kubernetes.io/docs/concepts/configuration/secret.md#decoding-a-secret">解码 secret</a> 了解如何查看它们的内容。</p>

<h4 id="手动创建-secret">手动创建 Secret</h4>

<p>您也可以先以 json 或 yaml 格式在文件中创建一个 secret 对象，然后创建该对象。</p>

<p>每一项必须是 base64 编码：</p>

<pre><code class="language-bash">$ echo -n &quot;admin&quot; | base64
YWRtaW4=
$ echo -n &quot;1f2d1e2e67df&quot; | base64
MWYyZDFlMmU2N2Rm
</code></pre>

<p>现在可以像这样写一个 secret 对象：</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
</code></pre>

<p>数据字段是一个映射。它的键必须匹配 <a href="https://git.k8s.io/community/contributors/design-proposals/identifiers.md">DNS_SUBDOMAIN</a>，前导点也是可以的。这些值可以是任意数据，使用 base64 进行编码。</p>

<p>使用 <a href="https://kubernetes.io/docs/user-guide/kubectl/v1.7/#create"><code>kubectl create</code></a> 创建 secret：</p>

<pre><code class="language-bash">$ kubectl create -f ./secret.yaml
secret &quot;mysecret&quot; created
</code></pre>

<p><strong>编码注意：</strong> secret 数据的序列化 JSON 和 YAML 值使用 base64 编码成字符串。换行符在这些字符串中无效，必须省略。当在Darwin/OS X上使用 <code>base64</code> 实用程序时，用户应避免使用 <code>-b</code> 选项来拆分长行。另外，对于 Linux用户如果 <code>-w</code> 选项不可用的话，应该添加选项 <code>-w 0</code> 到 <code>base64</code> 命令或管道 <code>base64 | tr -d '\n'</code> 。</p>

<h4 id="解码-secret">解码 Secret</h4>

<p>可以使用 <code>kubectl get secret</code> 命令获取 secret。例如，获取在上一节中创建的 secret：</p>

<pre><code class="language-bash">$ kubectl get secret mysecret -o yaml
apiVersion: v1
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
kind: Secret
metadata:
  creationTimestamp: 2016-01-22T18:41:56Z
  name: mysecret
  namespace: default
  resourceVersion: &quot;164619&quot;
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: cfee02d6-c137-11e5-8d73-42010af00002
type: Opaque
</code></pre>

<p>解码密码字段：</p>

<pre><code class="language-bash">$ echo &quot;MWYyZDFlMmU2N2Rm&quot; | base64 --decode
1f2d1e2e67df
</code></pre>

<h3 id="使用-secret">使用 Secret</h3>

<p>Secret 可以作为数据卷被挂载，或作为环境变量暴露出来以供 pod 中的容器使用。它们也可以被系统的其他部分使用，而不直接暴露在 pod 内。例如，它们可以保存凭据，系统的其他部分应该用它来代表您与外部系统进行交互。</p>

<h4 id="在-pod-中使用-secret-文件">在 Pod 中使用 Secret 文件</h4>

<p>在 Pod 中的 volume 里使用 Secret：</p>

<ol>
<li><p>创建一个 secret 或者使用已有的 secret。多个 pod 可以引用同一个 secret。</p></li>

<li><p>修改您的 pod 的定义在 <code>spec.volumes[]</code> 下增加一个 volume。可以给这个 volume 随意命名，它的 <code>spec.volumes[].secret.secretName</code> 必须等于 secret 对象的名字。</p></li>

<li><p>将下面的配置</p>

<pre><code class="language-ini">spec.containers[].volumeMounts[]
</code></pre>

<p>​   加到需要用到该 secret 的容器中。指定下面的配置</p>

<pre><code class="language-ini">spec.containers[].volumeMounts[].readOnly = true
</code></pre>

<p>​   并设置</p>

<pre><code class="language-ini">spec.containers[].volumeMounts[].mountPath
</code></pre>

<p>​   为您想要该 secret 出现的尚未使用的目录。</p></li>

<li><p>修改您的镜像并且／或者命令行让程序从该目录下寻找文件。Secret 的 <code>data</code> 映射中的每一个键都成为了 <code>mountPath</code> 下的一个文件名。</p></li>
</ol>

<p>这是一个在 pod 中使用 volume 挂在 secret 的例子：</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
</code></pre>

<p>您想要用的每个 secret 都需要在 <code>spec.volumes</code> 中指明。</p>

<p>如果 pod 中有多个容器，每个容器都需要自己的 <code>volumeMounts</code> 配置块，但是每个 secret 只需要一个 <code>spec.volumes</code>。</p>

<p>您可以打包多个文件到一个 secret 中，或者使用的多个 secret，怎样方便就怎样来。</p>

<p><strong>向特性路径映射 secret 密钥</strong></p>

<p>我们还可以控制 Secret key 映射在 volume 中的路径。您可以使用 <code>spec.volumes[].secret.items</code> 字段修改每个 key 的目标路径：</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
</code></pre>

<p>将会发生什么呢：</p>

<ul>
<li><code>username</code> secret 存储在 <code>/etc/foo/my-group/my-username</code> 文件中而不是 <code>/etc/foo/username</code> 中。</li>
<li><code>password</code> secret 没有被影射</li>
</ul>

<p>如果使用了 <code>spec.volumes[].secret.items</code>，只有在 <code>items</code> 中指定的 key 被影射。要使用 secret 中所有的 key，所有这些都必须列在 <code>items</code> 字段中。所有列出的密钥必须存在于相应的 secret 中。否则，不会创建卷。</p>

<p><strong>Secret 文件权限</strong></p>

<p>您还可以指定 secret 将拥有的权限模式位文件。如果不指定，默认使用 <code>0644</code>。您可以为整个保密卷指定默认模式，如果需要，可以覆盖每个密钥。</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      defaultMode: 256
</code></pre>

<p>然后，secret 将被挂载到 <code>/etc/foo</code> 目录，所有通过该 secret volume 挂载创建的文件的权限都是 <code>0400</code>。</p>

<p>请注意，JSON 规范不支持八进制符号，因此使用 256 值作为 0400 权限。如果您使用 yaml 而不是 json 作为 pod，则可以使用八进制符号以更自然的方式指定权限。</p>

<p>您还可以是用映射，如上一个示例，并为不同的文件指定不同的权限，如下所示：</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
        mode: 511
</code></pre>

<p>在这种情况下，导致 <code>/etc/foo/my-group/my-username</code> 的文件的权限值为 <code>0777</code>。由于 JSON 限制，必须以十进制格式指定模式。</p>

<p>请注意，如果稍后阅读此权限值可能会以十进制格式显示。</p>

<p><strong>从 Volume 中消费 secret 值</strong></p>

<p>在挂载的 secret volume 的容器内，secret key 将作为文件，并且 secret 的值使用 base-64 解码并存储在这些文件中。这是在上面的示例容器内执行的命令的结果：</p>

<pre><code class="language-bash">$ ls /etc/foo/
username
password
$ cat /etc/foo/username
admin
$ cat /etc/foo/password
1f2d1e2e67df
</code></pre>

<p>容器中的程序负责从文件中读取 secret。</p>

<p><strong>挂载的 secret 被自动更新</strong></p>

<p>当已经在 volume 中消被消费的 secret 被更新时，被映射的 key 也将被更新。</p>

<p>Kubelet 在周期性同步时检查被挂载的 secret 是不是最新的。但是，它正在使用其基于本地 ttl 的缓存来获取当前的 secret 值。结果是，当 secret 被更新的时刻到将新的 secret 映射到 pod 的时刻的总延迟可以与 kubelet 中的secret 缓存的 kubelet sync period + ttl 一样长。</p>

<h4 id="secret-作为环境变量">Secret 作为环境变量</h4>

<p>将 secret 作为 pod 中的环境变量使用：</p>

<ol>
<li>创建一个 secret 或者使用一个已存在的 secret。多个 pod 可以引用同一个 secret。</li>
<li>在每个容器中修改您想要使用 secret key 的 Pod 定义，为要使用的每个 secret key 添加一个环境变量。消费secret key 的环境变量应填充 secret 的名称，并键入 <code>env[x].valueFrom.secretKeyRef</code>。</li>
<li>修改镜像并／或者命令行，以便程序在指定的环境变量中查找值。</li>
</ol>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
  restartPolicy: Never
</code></pre>

<p><strong>消费环境变量里的 Secret 值</strong></p>

<p>在一个消耗环境变量 secret 的容器中，secret key 作为包含 secret 数据的 base-64 解码值的常规环境变量。这是从上面的示例在容器内执行的命令的结果：</p>

<pre><code class="language-bash">$ echo $SECRET_USERNAME
admin
$ echo $SECRET_PASSWORD
1f2d1e2e67df
</code></pre>

<h4 id="使用-imagepullsecret">使用 imagePullSecret</h4>

<p>imagePullSecret 是将包含 Docker（或其他）镜像注册表密码的 secret 传递给 Kubelet 的一种方式，因此可以代表您的 pod 拉取私有镜像。</p>

<p><strong>手动指定 imagePullSecret</strong></p>

<p>imagePullSecret 的使用在 <a href="https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod">镜像文档</a> 中说明。</p>

<h3 id="安排-imagepullsecrets-自动附加">安排 imagePullSecrets 自动附加</h3>

<p>您可以手动创建 imagePullSecret，并从 serviceAccount 引用它。使用该 serviceAccount 创建的任何 pod 和默认使用该 serviceAccount 的 pod 将会将其的 imagePullSecret 字段设置为服务帐户的 imagePullSecret 字段。有关该过程的详细说明，请参阅 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#adding-imagepullsecrets-to-a-service-account">将 ImagePullSecrets 添加到服务帐户</a>。</p>

<h4 id="自动挂载手动创建的-secret">自动挂载手动创建的 Secret</h4>

<p>手动创建的 secret（例如包含用于访问 github 帐户的令牌）可以根据其服务帐户自动附加到 pod。请参阅 <a href="https://kubernetes.io/docs/tasks/run-application/podpreset">使用 PodPreset 向 Pod 中注入信息</a> 以获取该进程的详细说明。</p>

<h2 id="详细">详细</h2>

<h3 id="限制">限制</h3>

<p>验证 secret volume 来源确保指定的对象引用实际上指向一个类型为 Secret 的对象。因此，需要在依赖于它的任何 pod 之前创建一个 secret。</p>

<p>Secret API 对象驻留在命名空间中。它们只能由同一命名空间中的 pod 引用。</p>

<p>每个 secret 的大小限制为1MB。这是为了防止创建非常大的 secret 会耗尽 apiserver 和 kubelet 的内存。然而，创建许多较小的 secret 也可能耗尽内存。更全面得限制 secret 对内存使用的更全面的限制是计划中的功能。</p>

<p>Kubelet 仅支持从 API server 获取的 Pod 使用 secret。这包括使用 kubectl 创建的任何 pod，或间接通过 replication controller 创建的 pod。它不包括通过 kubelet <code>--manifest-url</code> 标志，其 <code>--config</code> 标志或其 REST API 创建的pod（这些不是创建 pod 的常用方法）。</p>

<p>必须先创建 secret，除非将它们标记为可选项，否则必须在将其作为环境变量在 pod 中使用之前创建 secret。对不存在的 secret 的引用将阻止其启动。</p>

<p>通过 <code>secretKeyRef</code> 对不存在于命名的 key 中的 key 进行引用将阻止该启动。</p>

<p>用于通过 <code>envFrom</code> 填充环境变量的 secret，这些环境变量具有被认为是无效环境变量名称的 key 将跳过这些键。该 pod 将被允许启动。将会有一个事件，其原因是 <code>InvalidVariableNames</code>，该消息将包含被跳过的无效键的列表。该示例显示一个 pod，它指的是包含2个无效键，1badkey 和 2alsobad 的默认/mysecret ConfigMap。</p>

<pre><code class="language-bash">$ kubectl get events
LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre>

<h3 id="secret-与-pod-生命周期的联系">Secret 与 Pod 生命周期的联系</h3>

<p>通过 API 创建的 Pod 时，不会检查应用的 secret 是否存在。一旦 Pod 被调度，kubelet 就会尝试获取该 secret 的值。如果获取不到该 secret，或者暂时无法与 API server 建立连接，kubelet 将会定期重试。Kubelet 将会报告关于 pod 的事件，并解释它无法启动的原因。一旦获取的 secret，kubelet将创建并装载一个包含它的卷。在安装所有pod的卷之前，都不会启动 pod 的容器。</p>

<h2 id="使用案例">使用案例</h2>

<h3 id="使用案例-包含-ssh-密钥的-pod">使用案例：包含 ssh 密钥的 pod</h3>

<p>创建一个包含 ssh key 的 secret：</p>

<pre><code class="language-bash">$ kubectl create secret generic ssh-key-secret --from-file=ssh-privatekey=/path/to/.ssh/id_rsa --from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub
</code></pre>

<p><strong>安全性注意事项</strong>：发送自己的 ssh 密钥之前要仔细思考：集群的其他用户可能有权访问该密钥。使用您想要共享 Kubernetes 群集的所有用户可以访问的服务帐户，如果它们遭到入侵，可以撤销。</p>

<p>现在我们可以创建一个使用 ssh 密钥引用 secret 的pod，并在一个卷中使用它：</p>

<pre><code class="language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: secret-test-pod
  labels:
    name: secret-test
spec:
  volumes:
  - name: secret-volume
    secret:
      secretName: ssh-key-secret
  containers:
  - name: ssh-test-container
    image: mySshImage
    volumeMounts:
    - name: secret-volume
      readOnly: true
      mountPath: &quot;/etc/secret-volume&quot;
</code></pre>

<p>当容器中的命令运行时，密钥的片段将可在以下目录：</p>

<pre><code class="language-Ini">/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre>

<p>然后容器可以自由使用密钥数据建立一个 ssh 连接。</p>

<h3 id="使用案例-包含-prod-test-凭据的-pod">使用案例：包含 prod/test 凭据的 pod</h3>

<p>下面的例子说明一个 pod 消费一个包含 prod 凭据的 secret，另一个 pod 使用测试环境凭据消费 secret。</p>

<p>创建 secret：</p>

<pre><code class="language-bash">$ kubectl create secret generic prod-db-secret --from-literal=username=produser --from-literal=password=Y4nys7f11
secret &quot;prod-db-secret&quot; created
$ kubectl create secret generic test-db-secret --from-literal=username=testuser --from-literal=password=iluvtests
secret &quot;test-db-secret&quot; created
</code></pre>

<p>创建 pod ：</p>

<pre><code class="language-yaml">apiVersion: v1
kind: List
items:
- kind: Pod
  apiVersion: v1
  metadata:
    name: prod-db-client-pod
    labels:
      name: prod-db-client
  spec:
    volumes:
    - name: secret-volume
      secret:
        secretName: prod-db-secret
    containers:
    - name: db-client-container
      image: myClientImage
      volumeMounts:
      - name: secret-volume
        readOnly: true
        mountPath: &quot;/etc/secret-volume&quot;
- kind: Pod
  apiVersion: v1
  metadata:
    name: test-db-client-pod
    labels:
      name: test-db-client
  spec:
    volumes:
    - name: secret-volume
      secret:
        secretName: test-db-secret
    containers:
    - name: db-client-container
      image: myClientImage
      volumeMounts:
      - name: secret-volume
        readOnly: true
        mountPath: &quot;/etc/secret-volume&quot;
</code></pre>

<p>这两个容器将在其文件系统上显示以下文件，其中包含每个容器环境的值：</p>

<pre><code class="language-Ini">/etc/secret-volume/username
/etc/secret-volume/password
</code></pre>

<p>请注意，两个 pod 的 spec 配置中仅有一个字段有所不同；这有助于使用普通的 pod 配置模板创建具有不同功能的 pod。您可以使用两个 service account 进一步简化基本 pod spec：一个名为 <code>prod-user</code> 拥有 <code>prod-db-secret</code> ，另一个称为 <code>test-user</code> 拥有 <code>test-db-secret</code> 。然后，pod spec 可以缩短为，例如：</p>

<pre><code class="language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: prod-db-client-pod
  labels:
    name: prod-db-client
spec:
  serviceAccount: prod-db-client
  containers:
  - name: db-client-container
    image: myClientImage
</code></pre>

<h3 id="使用案例-secret-卷中以点号开头的文件">使用案例：secret 卷中以点号开头的文件</h3>

<p>为了将数据“隐藏”起来（即文件名以点号开头的文件），简单地说让该键以一个点开始。例如，当如下 secret 被挂载到卷中：</p>

<pre><code class="language-yaml">kind: Secret
apiVersion: v1
metadata:
  name: dotfile-secret
data:
  .secret-file: dmFsdWUtMg0KDQo=
---
kind: Pod
apiVersion: v1
metadata:
  name: secret-dotfiles-pod
spec:
  volumes:
  - name: secret-volume
    secret:
      secretName: dotfile-secret
  containers:
  - name: dotfile-test-container
    image: gcr.io/google_containers/busybox
    command:
    - ls
    - &quot;-l&quot;
    - &quot;/etc/secret-volume&quot;
    volumeMounts:
    - name: secret-volume
      readOnly: true
      mountPath: &quot;/etc/secret-volume&quot;
</code></pre>

<p><code>Secret-volume</code> 将包含一个单独的文件，叫做 <code>.secret-file</code>，<code>dotfile-test-container</code> 的 <code>/etc/secret-volume/.secret-file</code>路径下将有该文件。</p>

<p><strong>注意</strong></p>

<p>以点号开头的文件在 <code>ls -l</code> 的输出中被隐藏起来了；列出目录内容时，必须使用 <code>ls -la</code> 才能查看它们。</p>

<h3 id="使用案例-secret-仅对-pod-中的一个容器可见">使用案例：Secret 仅对 pod 中的一个容器可见</h3>

<p>考虑以下一个需要处理 HTTP 请求的程序，执行一些复杂的业务逻辑，然后使用 HMAC 签署一些消息。因为它具有复杂的应用程序逻辑，所以在服务器中可能会出现一个未被注意的远程文件读取漏洞，这可能会将私钥暴露给攻击者。</p>

<p>这可以在两个容器中分为两个进程：前端容器，用于处理用户交互和业务逻辑，但无法看到私钥；以及可以看到私钥的签名者容器，并且响应来自前端的简单签名请求（例如通过本地主机网络）。</p>

<p>使用这种分割方法，攻击者现在必须欺骗应用程序服务器才能进行任意的操作，这可能比使其读取文件更难。</p>

<h2 id="最佳实践">最佳实践</h2>

<h3 id="客户端使用-secret-api">客户端使用 secret API</h3>

<p>当部署与 secret API 交互的应用程序时，应使用诸如 <a href="https://kubernetes.io/docs/admin/authorization/rbac/">RBAC</a> 之类的 <a href="https://kubernetes.io/docs/admin/authorization/">授权策略</a> 来限制访问。</p>

<p>Secret 的重要性通常不尽相同，其中许多可能只对 Kubernetes 集群内（例如 service account 令牌）和对外部系统造成影响。即使一个应用程序可以理解其期望的与之交互的 secret 的权力，但是同一命名空间中的其他应用程序也可以使这些假设无效。</p>

<p>由于这些原因，在命名空间中 <code>watch</code> 和 <code>list</code> secret 的请求是非常强大的功能，应该避免这样的行为，因为列出 secret 可以让客户端检查所有 secret 是否在该命名空间中。在群集中<code>watch</code> 和 <code>list</code> 所有 secret 的能力应该只保留给最有特权的系统级组件。</p>

<p>需要访问 secrets API 的应用程序应该根据他们需要的 secret 执行 <code>get</code> 请求。这允许管理员限制对所有 secret 的访问，同时设置 <a href="https://kubernetes.io/docs/admin/authorization/rbac/#referring-to-resources">白名单访问</a> 应用程序需要的各个实例。</p>

<p>为了提高循环获取的性能，客户端可以设计引用 secret 的资源，然后 <code>watch</code> 资源，在引用更改时重新请求 secret。此外，还提出了一种 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/bulk_watch.md">”批量监控“ API</a> 来让客户端 <code>watch</code> 每个资源，该功能可能会在将来的 Kubernetes 版本中提供。</p>

<h2 id="安全属性">安全属性</h2>

<h3 id="保护">保护</h3>

<p>因为 <code>secret</code> 对象可以独立于使用它们的 <code>pod</code> 而创建，所以在创建、查看和编辑 pod 的流程中 secret 被暴露的风险较小。系统还可以对 <code>secret</code> 对象采取额外的预防措施，例如避免将其写入到磁盘中可能的位置。</p>

<p>只有当节点上的 pod 需要用到该 secret 时，该 secret 才会被发送到该节点上。它不会被写入磁盘，而是存储在 tmpfs 中。一旦依赖于它的 pod 被删除，它就被删除。</p>

<p>在大多数 Kubernetes 项目维护的发行版中，用户与 API server 之间的通信以及从 API server 到 kubelet 的通信都受到 SSL/TLS 的保护。通过这些通道传输时，secret 受到保护。</p>

<p>节点上的 secret 数据存储在 tmpfs 卷中，因此不会传到节点上的其他磁盘。</p>

<p>同一节点上的很多个 pod 可能拥有多个 secret。但是，只有 pod 请求的 secret 在其容器中才是可见的。因此，一个 pod 不能访问另一个 Pod 的 secret。</p>

<p>Pod 中有多个容器。但是，pod 中的每个容器必须请求其挂载卷中的 secret 卷才能在容器内可见。这可以用于 <a href="https://kubernetes.io/docs/concepts/configuration/secret.md#use-case-secret-visible-to-one-container-in-a-pod">在 Pod 级别构建安全分区</a>。</p>

<h3 id="风险">风险</h3>

<ul>
<li>API server 的 secret 数据以纯文本的方式存储在 etcd 中；因此：

<ul>
<li>管理员应该限制 admin 用户访问 etcd；</li>
<li>API server 中的 secret 数据位于 etcd 使用的磁盘上；管理员可能希望在不再使用时擦除/粉碎 etcd 使用的磁盘</li>
</ul></li>
<li>如果您将 secret 数据编码为 base64 的清单（JSON 或 YAML）文件，共享该文件或将其检入代码库，这样的话该密码将会被泄露。 Base64 编码不是一种加密方式，一样也是纯文本。</li>
<li>应用程序在从卷中读取 secret 后仍然需要保护 secret 的值，例如不会意外记录或发送给不信任方。</li>
<li>可以创建和使用 secret 的 pod 的用户也可以看到该 secret 的值。即使 API server 策略不允许用户读取 secret 对象，用户也可以运行暴露 secret 的 pod。</li>
<li>如果运行了多个副本，那么这些 secret 将在它们之间共享。默认情况下，etcd 不能保证与 SSL/TLS 的对等通信，尽管可以进行配置。</li>
<li>目前，任何节点的 root 用户都可以通过模拟 kubelet 来读取 API server 中的任何 secret。只有向实际需要它们的节点发送 secret 才能限制单个节点的根漏洞的影响，该功能还在计划中。</li>
</ul>

<p><a href="https://github.com/rootsongjc/kubernetes.github.io/blob/master/docs/concepts/configuration/secret.md">查看原文</a></p>

            </article>

            <ul class="pager blog-pager">
                
                <li class="previous">
                    <a href="https://jimmysong.io/posts/creating-comment-box-with-gitment/" data-toggle="tooltip" data-placement="top" title="使用gitment为你的网站添加评论框">&larr; Previous Post</a>
                </li>
                 
                <li class="next">
                    <a href="https://jimmysong.io/posts/jimmysong-io-revision-20171001/" data-toggle="tooltip" data-placement="top" title="喜迎国庆节jimmysong.io博客盛装改版">Next Post &rarr;</a>
                </li>
                
            </ul>
            
            <div>
                 
                <h2>See Also</h2>
                <ul>
                    
                    <li><a href="/posts/pod-lifecycle/">Kubernetes中Pod的生命周期</a></li>
                    
                    <li><a href="/posts/docker-cli-to-kubectl/">docker用户过渡到kubectl命令行指南</a></li>
                    
                    <li><a href="/posts/running-spark-with-kubernetes-native-scheduler/">运行支持kubernetes原生调度的spark程序-Spark on Kubernetes</a></li>
                    
                    <li><a href="/posts/3-things-every-cto-should-know-about-kubernetes/">每位CTO都该知道的关于kubernetes的三件事</a></li>
                    
                    <li><a href="/posts/kubectl-user-authentication-authorization/">kubectl的用户认证授权</a></li>
                    
                </ul>
                
            </div>
            
            
            
            
<div>
    <section id="datecount">
        <h4 id="date"> Thu Sep 28, 2017</h4>
    </section>
    <h5 id="wc">5900 Words|Read in about 12 Min</h5>
    <h5 id="tags">Tags: 
        
        <a href="https://jimmysong.io/tags/kubernetes/">kubernetes</a> &nbsp;
    </h5>
</div>

            
            </div>
            
            
        </div>
    </div>
    </section>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
        <img src="https://ws1.sinaimg.cn/large/00704eQkly1fs0lebokxaj30a004gq44.jpg">
          
              <li>
                <a href="mailto:jimmysong@jimmysong.io" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://www.facebook.com/jimmysongio" title="Facebook">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/rootsongjc" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/jimmysongio" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/jimmysongio" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="https://jimmysong.io/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
        &copy;2017-2018
          
            
              <a href="https://jimmysong.io">Jimmy Song(宋净超)</a>
            
          
          
          
            &nbsp;&bull;&nbsp;
            <a href="https://jimmysong.io/">Jimmy Song</a>
          
        </p>
        <p class="credits theme-by text-muted">
        <a href="https://servicemesher.github.io">ServiceMesher</a>&nbsp;&bull;&nbsp;<a href="https://dataikudss.com">dataikudss.com</a>&nbsp;&bull;&nbsp;<a href="https://cloudnativego.com">cloudnativego.com</a>
        </p>

        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.40</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/bootstrap.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe-ui-default.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/auto-render.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/main.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/prism.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/katex.min.js"></script>
<script> renderMathInElement(document.body); </script>







  </body>
</html>

